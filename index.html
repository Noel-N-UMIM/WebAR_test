<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MindAR Game Example</title>
    
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>

    <style>
      /* Style for the Jump Button */
      #ui-layer {
        position: absolute;
        bottom: 30px;
        left: 0;
        width: 100%;
        text-align: center;
        z-index: 100;
        display: none; /* Hidden until target is found */
      }
      
      #jump-btn {
        background-color: #ff4081;
        color: white;
        border: 4px solid white;
        padding: 20px 40px;
        font-size: 24px;
        font-weight: bold;
        border-radius: 50px;
        font-family: sans-serif;
        text-transform: uppercase;
        box-shadow: 0px 4px 10px rgba(0,0,0,0.5);
      }

      #jump-btn:active {
        background-color: #d81b60;
        transform: scale(0.95);
      }
      
      #game-over-msg {
        display: none;
        background: rgba(0,0,0,0.8);
        color: red;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px;
        font-family: sans-serif;
        font-weight: bold;
      }
    </style>

    <script>
      // --- EXISTING COMPONENT: FOLLOW TARGET (With your smoothing logic) ---
      AFRAME.registerComponent('follow-target', {
        schema: {
          target: { type: 'selector' },
          isTracking: { type: 'boolean', default: false },
          smoothFactor: { type: 'number', default: 0.1 } // Adjusted to 0.1 for smoother drift
        },
        
        init: function() {
          this.targetPos = new THREE.Vector3();
          this.targetQuat = new THREE.Quaternion();
          this.targetScale = new THREE.Vector3();
        },

        tick: function (time, timeDelta) {
          if (!this.data.isTracking) return;
          
          const targetEl = this.data.target;
          if (!targetEl || !targetEl.object3D.visible) return;

          const elObj = this.el.object3D;
          const targetObj = targetEl.object3D;

          targetObj.getWorldPosition(this.targetPos);
          targetObj.getWorldQuaternion(this.targetQuat);
          targetObj.getWorldScale(this.targetScale);

          const dist = elObj.position.distanceTo(this.targetPos);
          if (dist > 2) {
             elObj.position.copy(this.targetPos);
             elObj.quaternion.copy(this.targetQuat);
             elObj.scale.copy(this.targetScale);
          } else {
             const factor = this.data.smoothFactor;
             elObj.position.lerp(this.targetPos, factor);
             elObj.quaternion.slerp(this.targetQuat, factor);
             elObj.scale.lerp(this.targetScale, factor);
          }
        },
        
        startTracking: function () {
          this.data.isTracking = true;
          this.el.setAttribute('visible', 'true');
        },
        
        stopTracking: function () {
          this.data.isTracking = false;
        }
      });

      // --- NEW COMPONENT: PLAYER CONTROLLER (JUMP LOGIC) ---
      AFRAME.registerComponent('player-jump', {
        schema: {
          isJumping: { type: 'boolean', default: false },
          jumpHeight: { type: 'number', default: 0.5 },
          groundY: { type: 'number', default: 0 }
        },

        init: function() {
          this.velocity = 0;
          this.gravity = -0.002; // Simple gravity
          this.jumpPower = 0.08;
          
          // Bind button to this component
          const btn = document.querySelector('#jump-btn');
          btn.addEventListener('click', () => {
            this.triggerJump();
          });
          
          // Start running animation
          this.el.setAttribute('animation-mixer', {
            clip: 'Running',
            loop: 'repeat',
            crossFadeDuration: 0.4
          });
        },

        triggerJump: function() {
          if (this.data.isJumping) return; // Prevent double jumping
          
          this.data.isJumping = true;
          this.velocity = this.jumpPower;
          
          // Switch to Jump animation
          this.el.setAttribute('animation-mixer', {
            clip: 'Jump',
            loop: 'once',
            crossFadeDuration: 0.2
          });
        },

        tick: function(time, timeDelta) {
          if (!this.data.isJumping) return;

          // Physics Logic
          const el = this.el;
          let currentY = el.object3D.position.y;
          
          // Apply velocity
          currentY += this.velocity * (timeDelta / 16); // Normalize for framerate
          this.velocity += this.gravity * (timeDelta / 16);

          // Floor collision
          if (currentY <= this.data.groundY) {
            currentY = this.data.groundY;
            this.data.isJumping = false;
            this.velocity = 0;
            
            // Back to running
            this.el.setAttribute('animation-mixer', {
              clip: 'Running',
              loop: 'repeat',
              crossFadeDuration: 0.2
            });
          }

          el.object3D.position.y = currentY;
        }
      });

      // --- NEW COMPONENT: GAME MANAGER (SPAWN OBSTACLES) ---
      AFRAME.registerComponent('game-manager', {
        schema: {
          isPlaying: { type: 'boolean', default: true },
          speed: { type: 'number', default: 0.02 }
        },

        init: function() {
          this.obstacles = [];
          this.timer = 0;
          this.spawnRate = 2000; // Spawn every 2 seconds
          
          this.player = document.querySelector('#robot-model');
          this.gameOverMsg = document.querySelector('#game-over-msg');
        },

        tick: function(time, timeDelta) {
          if (!this.data.isPlaying) return;

          this.timer += timeDelta;
          
          // 1. Spawn Obstacles
          if (this.timer > this.spawnRate) {
            this.spawnObstacle();
            this.timer = 0;
            // Make game harder over time
            if (this.spawnRate > 800) this.spawnRate -= 50; 
          }

          // 2. Move Obstacles & Check Collision
          for (let i = 0; i < this.obstacles.length; i++) {
            const obs = this.obstacles[i];
            const pos = obs.object3D.position;
            
            // Move left
            pos.x -= this.data.speed * (timeDelta / 16);

            // Cleanup if off screen
            if (pos.x < -1) {
              obs.parentNode.removeChild(obs);
              this.obstacles.splice(i, 1);
              i--;
              continue;
            }

            // COLLISION DETECTION
            // Simple distance check. Adjust distance based on model size.
            if (this.player) {
              const playerPos = this.player.object3D.position;
              
              // Only check X and Y distance
              const dx = Math.abs(pos.x - playerPos.x); // Horizontal distance
              const dy = Math.abs(pos.y - playerPos.y); // Vertical (jump) distance
              
              // Hitbox size: 0.2
              if (dx < 0.15 && dy < 0.2) {
                this.gameOver();
              }
            }
          }
        },

        spawnObstacle: function() {
          const parent = this.el; // Attach to the persistent content so it moves with the card
          const box = document.createElement('a-box');
          
          box.setAttribute('color', 'red');
          box.setAttribute('scale', '0.15 0.15 0.15');
          box.setAttribute('position', '1 0 0'); // Start on the right side
          
          parent.appendChild(box);
          this.obstacles.push(box);
        },

        gameOver: function() {
          this.data.isPlaying = false;
          this.gameOverMsg.style.display = 'block';
          this.gameOverMsg.innerText = "GAME OVER! Reload to restart.";
          
          // Play Death Animation
          this.player.setAttribute('animation-mixer', {
            clip: 'Death',
            loop: 'once',
            clampWhenFinished: true
          });
        }
      });

      // DOM Loaded Listener
      document.addEventListener("DOMContentLoaded", function() {
        const exampleTarget = document.querySelector('#example-target');
        const content = document.querySelector('#persistent-content');
        const uiLayer = document.querySelector('#ui-layer');

        if(exampleTarget && content) {
          
          exampleTarget.addEventListener("targetFound", event => {
            console.log("Target Found");
            content.components['follow-target'].startTracking();
            uiLayer.style.display = 'block'; // Show Jump Button
          });

          exampleTarget.addEventListener("targetLost", event => {
            console.log("Target Lost");
            content.components['follow-target'].stopTracking();
            // We keep the game running and button visible
            // If you want to pause the game on loss, you'd access the game-manager component here
          });
          
        }
      });
    </script>
  </head>
  <body>
    <div id="ui-layer">
      <div id="game-over-msg"></div>
      <button id="jump-btn">JUMP</button>
    </div>

    <a-scene 
      mindar-image="imageTargetSrc: targets.mind; uiScanning: no; missTolerance: 3; warmupTolerance: 2;" 
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false">
      
      <a-assets>
