<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MindAR Game: 3D Player & 3D Obstacles</title>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.4.0/dist/aframe-extras.min.js" crossorigin="anonymous"></script>

    <style>
      body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
      
      /* Main UI Layer */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 999;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        padding-bottom: 30px;
      }

      /* Buttons */
      .game-btn {
        pointer-events: auto;
        border: 3px solid white;
        color: white;
        font-weight: 800;
        text-transform: uppercase;
        border-radius: 50px;
        cursor: pointer;
        box-shadow: 0px 4px 10px rgba(0,0,0,0.5);
        transition: transform 0.1s, background 0.2s;
        display: none;
        text-align: center;
        user-select: none;
      }

      .game-btn:active {
        transform: scale(0.95);
      }

      #start-btn {
        background: #4CAF50;
        padding: 15px 40px;
        font-size: 24px;
        margin-bottom: 80px; 
      }

      #jump-btn {
        background: #2196F3;
        padding: 25px 80px; 
        font-size: 28px;
        margin-bottom: 20px;
      }

      #restart-btn {
        background: #f44336;
        padding: 15px 40px;
        font-size: 24px;
        margin-bottom: 80px;
      }

      #status-msg {
        position: absolute;
        top: 40%;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 20px 30px;
        border-radius: 20px;
        font-size: 20px;
        text-align: center;
        pointer-events: none;
        display: block;
      }
    </style>

    <script>
      /**
       * COMPONENT: PLAYER CONTROLLER
       * Handles physics, jumping, and model state (animations).
       */
      AFRAME.registerComponent('player-controller', {
        schema: {
          jumpForce: { type: 'number', default: 0.05 },
          gravity: { type: 'number', default: -0.0025 },
          groundY: { type: 'number', default: 0 } // 0 is typical for models (feet at origin)
        },
        init: function() {
          this.velocity = 0;
          this.isJumping = false;
          this.isDead = false;
          
          // Store the initial rotation set in HTML so we can reset to it
          // (Models often need specific rotations like 0 90 0)
          this.initialRotation = Object.assign({}, this.el.getAttribute('rotation'));
        },
        jump: function() {
          if (this.isJumping || this.isDead) return;
          this.velocity = this.data.jumpForce;
          this.isJumping = true;
          
          // OPTIONAL: If your model has a specific jump clip, play it here:
          // this.el.setAttribute('animation-mixer', 'clip: Jump; loop: once');
        },
        reset: function() {
          this.isDead = false;
          this.isJumping = false;
          this.velocity = 0;
          this.el.object3D.position.y = this.data.groundY;
          
          // Reset Rotation to what it was at start
          this.el.setAttribute('rotation', this.initialRotation);
          
          // Resume Animation (e.g. Run/Idle)
          this.el.setAttribute('animation-mixer', 'timeScale: 1');
        },
        die: function() {
          this.isDead = true;
          
          // Pause Animation (Freeze frame)
          this.el.setAttribute('animation-mixer', 'timeScale: 0'); 
          
          // Tip over effect
          // We keep the current Y rotation but tip Z to 90
          const currentRot = this.el.getAttribute('rotation');
          this.el.setAttribute('rotation', {
            x: currentRot.x, 
            y: currentRot.y, 
            z: 90
          }); 
        },
        tick: function(time, timeDelta) {
          if (this.isDead) return;

          // Physics Logic
          if (this.isJumping || this.el.object3D.position.y > this.data.groundY) {
            const dt = timeDelta / 16; 
            this.velocity += this.data.gravity * dt;
            
            let newY = this.el.object3D.position.y + (this.velocity * dt);

            // Hit Floor
            if (newY <= this.data.groundY) {
              newY = this.data.groundY;
              this.velocity = 0;
              this.isJumping = false;
              
              // Reset visual tilt from jump if we aren't using animation clips
              // If you are using animation clips, switch back to 'Run' here
            }
            
            this.el.object3D.position.y = newY;
          }
        }
      });

      /**
       * COMPONENT: GAME MANAGER
       */
      AFRAME.registerComponent('game-manager', {
        schema: {
          obstacleScale: { type: 'vec3', default: {x: 0.1, y: 0.1, z: 0.1} },
          obstacleY: { type: 'number', default: 0 },
          obstacleRotation: { type: 'vec3', default: {x: 0, y: 90, z: 0} },
          collisionThreshold: { type: 'number', default: 0.25 }
        },

        init: function() {
          this.uiStart = document.getElementById('start-btn');
          this.uiJump = document.getElementById('jump-btn');
          this.uiRestart = document.getElementById('restart-btn');
          this.statusMsg = document.getElementById('status-msg');
          this.player = document.getElementById('player');
          this.gameContainer = document.getElementById('game-container');
          
          this.isPlaying = false;
          this.isGameOver = false;
          this.obstacles = [];
          this.timer = 0;
          this.spawnInterval = 2000;
          this.gameSpeed = 0.03;

          this.uiStart.style.display = 'none';
          this.uiJump.style.display = 'none';
          this.uiRestart.style.display = 'none';
          this.statusMsg.innerText = "Scan Target to Play";

          this.uiStart.addEventListener('click', () => this.startGame());
          this.uiRestart.addEventListener('click', () => this.startGame());
          
          const handleJump = (e) => {
            e.preventDefault(); 
            if (this.isPlaying && !this.isGameOver) {
              this.player.components['player-controller'].jump();
            }
          };
          this.uiJump.addEventListener('mousedown', handleJump);
          this.uiJump.addEventListener('touchstart', handleJump);

          const target = document.getElementById('image-target');
          
          target.addEventListener('targetFound', () => {
            console.log("Target Found");
            this.gameContainer.setAttribute('visible', 'true');
            if (!this.isPlaying && !this.isGameOver) {
              this.statusMsg.style.display = 'none';
              this.uiStart.style.display = 'block';
            }
          });

          target.addEventListener('targetLost', () => {
            console.log("Target Lost");
            this.statusMsg.style.display = 'block';
            this.statusMsg.innerText = "Target Lost. Scan Image.";
            this.uiStart.style.display = 'none';
            this.uiJump.style.display = 'none';
            this.uiRestart.style.display = 'none';
            this.isPlaying = false; 
          });
        },

        startGame: function() {
          console.log("Game Started");
          this.isPlaying = true;
          this.isGameOver = false;
          this.obstacles = [];
          this.timer = 0;
          this.spawnInterval = 2000;
          this.gameSpeed = 0.03;

          this.player.components['player-controller'].reset();

          const oldObs = document.querySelectorAll('.obstacle');
          oldObs.forEach(el => {
            if (el.parentNode) el.parentNode.removeChild(el);
          });

          this.uiStart.style.display = 'none';
          this.uiRestart.style.display = 'none';
          this.statusMsg.style.display = 'none';
          this.uiJump.style.display = 'block';
        },

        gameOver: function() {
          console.log("Game Over");
          this.isPlaying = false;
          this.isGameOver = true;
          this.player.components['player-controller'].die();
          
          this.uiJump.style.display = 'none';
          this.uiRestart.style.display = 'block';
          this.statusMsg.style.display = 'block';
          this.statusMsg.innerText = "GAME OVER";
        },

        spawnObstacle: function() {
          const el = document.createElement('a-entity');
          el.setAttribute('class', 'obstacle');
          el.setAttribute('gltf-model', '#obstacle-model');
          el.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1');
          
          const s = this.data.obstacleScale;
          el.setAttribute('scale', `${s.x} ${s.y} ${s.z}`);

          const r = this.data.obstacleRotation;
          el.setAttribute('rotation', `${r.x} ${r.y} ${r.z}`);
          
          el.setAttribute('position', `1.5 ${this.data.obstacleY} 0`); 
          
          this.gameContainer.appendChild(el);
          this.obstacles.push(el);
        },

        tick: function(time, timeDelta) {
          if (!this.isPlaying) return;

          this.timer += timeDelta;
          if (this.timer > this.spawnInterval) {
            this.spawnObstacle();
            this.timer = 0;
            if (this.spawnInterval > 800) this.spawnInterval -= 50;
          }

          const playerPos = this.player.object3D.position;
          
          for (let i = 0; i < this.obstacles.length; i++) {
            const obs = this.obstacles[i];
            if (!obs.object3D) continue;

            obs.object3D.position.x -= this.gameSpeed * (timeDelta / 16);

            const dx = obs.object3D.position.x - playerPos.x;
            const dy = obs.object3D.position.y - playerPos.y;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if (distance < this.data.collisionThreshold) { 
              this.gameOver();
              return; 
            }

            if (obs.object3D.position.x < -1.5) {
              obs.parentNode.removeChild(obs);
              this.obstacles.splice(i, 1);
              i--;
            }
          }
        }
      });
    </script>
  </head>
  <body>

    <!-- 2D UI Overlay -->
    <div id="ui-layer">
      <div id="status-msg">Scan Target to Play</div>
      <div id="start-btn" class="game-btn">START GAME</div>
      <div id="restart-btn" class="game-btn">TRY AGAIN</div>
      <div id="jump-btn" class="game-btn">JUMP</div>
    </div>

    <!-- AR Scene -->
    <a-scene 
      mindar-image="imageTargetSrc: targets.mind; uiScanning: no;" 
      color-space="sRGB" 
      renderer="colorManagement: true" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false">

      <a-assets>
        <!-- Obstacle Model -->
        <a-asset-item id="obstacle-model" src="Present.glb"></a-asset-item>
        
        <!-- NEW: Player Model -->
        <!-- Ensure you have a 'player.glb' file in the same folder -->
        <a-asset-item id="player-model" src="Wolf.glb"></a-asset-item>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-light type="ambient" intensity="1"></a-light>
      <a-light type="directional" position="1 2 1" intensity="1.5"></a-light>

      <!-- Target Anchor -->
      <a-entity id="image-target" mindar-image-target="targetIndex: 0">
        
        <a-entity id="game-container" visible="false" game-manager>
          
          <!-- Floor Plane -->
          <a-plane 
            color="#FFFFFF" 
            opacity="0.3" 
            width="4" 
            height="2" 
            rotation="-90 0 0" 
            position="0 0 0">
          </a-plane>

          <!-- PLAYER ENTITY (New 3D Model) -->
          <!-- 
             Adjust 'scale' to fit your specific model size.
             Adjust 'rotation' if your model is facing the wrong way.
             'animation-mixer' will automatically play the default animation (Walk/Run).
          -->
          <a-entity 
            id="player" 
            gltf-model="#player-model"
            scale="0.4 0.4 0.4"
            rotation="0 180 0"
            position="-0.3 0 0"
            animation-mixer="clip: *; loop: repeat"
            player-controller="groundY: 0">
          </a-entity>

        </a-entity>
      </a-entity>
    </a-scene>
  </body>
</html>
